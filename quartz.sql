DROP TABLE IF EXISTS fired_triggers;
DROP TABLE IF EXISTS paused_trigger_groups;
DROP TABLE IF EXISTS scheduler_state;
DROP TABLE IF EXISTS locks;
DROP TABLE IF EXISTS simple_triggers;
DROP TABLE IF EXISTS simprop_triggers;
DROP TABLE IF EXISTS cron_triggers;
DROP TABLE IF EXISTS blob_triggers;
DROP TABLE IF EXISTS triggers;
DROP TABLE IF EXISTS job_details;
DROP TABLE IF EXISTS calendars;

CREATE TABLE `job_details` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  JOB_NAME VARCHAR(200) NOT NULL COMMENT '集群中 job 的名字',
  JOB_GROUP VARCHAR(200) NOT NULL COMMENT '集群中 job 的所属组的名字',
  JOB_CLASS_NAME VARCHAR(250) NOT NULL COMMENT '集群中个 note job 实现类的完全包名',
  DESCRIPTION VARCHAR(250) NULL COMMENT '',
  IS_DURABLE VARCHAR(1) NOT NULL COMMENT '是否持久化',
  IS_NONCONCURRENT VARCHAR(1) NOT NULL COMMENT '',
  IS_UPDATE_DATA VARCHAR(1) NOT NULL COMMENT '',
  REQUESTS_RECOVERY VARCHAR(1) NOT NULL COMMENT '',
  JOB_DATA BLOB NULL COMMENT '持久化 job 对象',
  PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
) ENGINE=InnoDB COMMENT '存储每一个已配置的 Job 的详细信息 ';

CREATE TABLE `triggers` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'trigger 的名字',
  TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'trigger 所属组的名字',
  JOB_NAME VARCHAR(200) NOT NULL COMMENT 'job_details 表 job_name 的外键',
  JOB_GROUP VARCHAR(200) NOT NULL COMMENT 'job_details 表 job_group 的外键',
  DESCRIPTION VARCHAR(250) NULL COMMENT '',
  NEXT_FIRE_TIME BIGINT(13) NULL COMMENT '',
  PREV_FIRE_TIME BIGINT(13) NULL COMMENT '',
  PRIORITY INTEGER NULL COMMENT '',
  TRIGGER_STATE VARCHAR(16) NOT NULL COMMENT '当前 trigger 状态，设置为 ACQUIRED, 如果设置为 WAITING, 则 job 不会触发',
  TRIGGER_TYPE VARCHAR(8) NOT NULL COMMENT '触发器类型, 使用 cron 表达式',
  START_TIME BIGINT(13) NOT NULL COMMENT '开始时间',
  END_TIME BIGINT(13) NULL COMMENT '结束时间',
  CALENDAR_NAME VARCHAR(200) NULL COMMENT '',
  MISFIRE_INSTR SMALLINT(2) NULL COMMENT '',
  JOB_DATA BLOB NULL COMMENT '',
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
  REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP)
) ENGINE=InnoDB COMMENT '存储已配置的 Trigger 的信息（trigger 信息的总表）';

CREATE TABLE `simple_triggers` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT '',
  TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT '',
  REPEAT_COUNT BIGINT(7) NOT NULL COMMENT '',
  REPEAT_INTERVAL BIGINT(12) NOT NULL COMMENT '',
  TIMES_TRIGGERED BIGINT(10) NOT NULL COMMENT '',
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
) ENGINE=InnoDB COMMENT '存储 Simple Trigger，包括重复次数，间隔，以及已触的次数（simple trigger 类型的详情表，通过 trigger_name 与总表关联）';

CREATE TABLE `cron_triggers` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'triggers 表 trigger_name 的外键',
  TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'triggers 表 trigger_group 的外键',
  CRON_EXPRESSION VARCHAR(120) NOT NULL COMMENT 'cron 表达式',
  TIME_ZONE_ID VARCHAR(80) COMMENT '时区 ID',
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
) ENGINE=InnoDB COMMENT '存储 Cron Trigger，包括 Cron 表达式和时区信息（cron trigger 类型的详情表，通过 trigger_name 与总表关联）';

CREATE TABLE `simprop_triggers` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT '',
  TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT '',
  STR_PROP_1 VARCHAR(512) NULL COMMENT '',
  STR_PROP_2 VARCHAR(512) NULL COMMENT '',
  STR_PROP_3 VARCHAR(512) NULL COMMENT '',
  INT_PROP_1 INT NULL COMMENT '',
  INT_PROP_2 INT NULL COMMENT '',
  LONG_PROP_1 BIGINT NULL COMMENT '',
  LONG_PROP_2 BIGINT NULL COMMENT '',
  DEC_PROP_1 NUMERIC(13,4) NULL COMMENT '',
  DEC_PROP_2 NUMERIC(13,4) NULL COMMENT '',
  BOOL_PROP_1 VARCHAR(1) NULL COMMENT '',
  BOOL_PROP_2 VARCHAR(1) NULL COMMENT '',
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
) ENGINE=InnoDB COMMENT '';

CREATE TABLE `blob_triggers` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT '',
  TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT '',
  BLOB_DATA BLOB NULL COMMENT '',
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  INDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
) ENGINE=InnoDB COMMENT '作为 Blob 类型存储 (用于 Quartz 用户用 JDBC 创建他们自己定制的 Trigger 类型，JobStore 并不知道如何存储实例的时候)';

CREATE TABLE `calendars` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  CALENDAR_NAME VARCHAR(200) NOT NULL COMMENT '',
  CALENDAR BLOB NOT NULL COMMENT '',
  PRIMARY KEY (SCHED_NAME,CALENDAR_NAME)
) ENGINE=InnoDB COMMENT '';

CREATE TABLE `paused_trigger_groups` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT '',
  PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP)
) ENGINE=InnoDB COMMENT '';

CREATE TABLE `fired_triggers` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  ENTRY_ID VARCHAR(95) NOT NULL COMMENT '',
  TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT '',
  TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT '',
  INSTANCE_NAME VARCHAR(200) NOT NULL COMMENT '',
  FIRED_TIME BIGINT(13) NOT NULL COMMENT '',
  SCHED_TIME BIGINT(13) NOT NULL COMMENT '',
  PRIORITY INTEGER NOT NULL COMMENT '',
  STATE VARCHAR(16) NOT NULL COMMENT '',
  JOB_NAME VARCHAR(200) NULL COMMENT '',
  JOB_GROUP VARCHAR(200) NULL COMMENT '',
  IS_NONCONCURRENT VARCHAR(1) NULL COMMENT '',
  REQUESTS_RECOVERY VARCHAR(1) NULL COMMENT '',
  PRIMARY KEY (SCHED_NAME,ENTRY_ID)
) ENGINE=InnoDB COMMENT '存储与已触发的 Trigger 相关的状态信息，以及相联 Job 的执行信息 QRTZ_PAUSED_TRIGGER_GRPS 存储已暂停的 Trigger 组的信息';

CREATE TABLE `scheduler_state` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  INSTANCE_NAME VARCHAR(200) NOT NULL COMMENT '之前配置文件中 org.quartz.scheduler.instanceId 配置的名字，就会写入该字段，如果设置为 AUTO,quartz 会根据物理机名和当前时间产生一个名字',
  LAST_CHECKIN_TIME BIGINT(13) NOT NULL COMMENT '上次检查时间',
  CHECKIN_INTERVAL BIGINT(13) NOT NULL COMMENT '检查间隔时间',
  PRIMARY KEY (SCHED_NAME,INSTANCE_NAME)
) ENGINE=InnoDB COMMENT '存储少量的有关 Scheduler 的状态信息，和别的 Scheduler 实例 (假如是用于一个集群中)';
# 存储集群中 note 实例信息，quartz 会定时读取该表的信息判断集群中每个实例的当前状态

CREATE TABLE `locks` (
  SCHED_NAME VARCHAR(120) NOT NULL COMMENT '',
  LOCK_NAME VARCHAR(40) NOT NULL COMMENT '',
  PRIMARY KEY (SCHED_NAME,LOCK_NAME)
) ENGINE=InnoDB COMMENT '存储程序的悲观锁的信息 (假如使用了悲观锁)';




CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);
CREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);

CREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);
CREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);
CREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);
CREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);
CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);

CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);
CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);
CREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);
CREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);
CREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);
CREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);

COMMIT;
